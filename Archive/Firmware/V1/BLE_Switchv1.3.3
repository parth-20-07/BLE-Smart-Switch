/*
  BLE SWITCH v1.0
  Date:10/04/2021
*/

#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <BLE2902.h>
#include <Arduino.h>
#include <Preferences.h>
#include <nvs_flash.h>
#include "FS.h"
#include "SPIFFS.h"
#include <Wire.h>
#include "RTClib.h"

#include "soc/timer_group_struct.h"
#include "soc/timer_group_reg.h"

#define SERVICE_UUID "208fc8fc-64ed-4423-ba22-2230821ae406"
#define CHARACTERISTIC_UUID "e462c4e9-3704-4af8-9a20-446fa2eef1d0"
#define AP1_pin 18
#define AP2_pin 19
#define SOS_Button 13
#define PIN_SCL 22
#define PIN_SDA 21
#define FORMAT_SPIFFS_IF_FAILED true
#define GATTS_CHAR_VAL_LEN_MAX 100
Preferences pref;
RTC_DS3231 rtc;
//--------------------Data Structure for Appliance Interface---------------------------------
typedef struct
{
  bool mData;           //Stores Manual Mode Value (0/1)
  unsigned int onMin;   //Stores ON time (in minutes) for Periodic Mode
  unsigned int offMin;  //Stores OFF time (in minutes) for Periodic Mode
  uint8_t tON[4];       //Stores FROM-TO (in Hr:Min) time interval for Timeframe Mode
} Data;

typedef struct
{
  char ID[3];       //Stores Interface ID
  bool curr_state;  //Stores Current state of interface
  bool prev_state;  //Stores previous state of Interface
  Data val[4];
} Interface;
uint8_t nInterface = 2;  //Number of available interfaces
Interface app[2];
char smode;       //Stores Interface Mode [Manual (M), Periodic (P), Timeframe (T)]
char delm = ',';  //CSV format using comma as delimeter
//-----------------Flags to control state of interfaces for various switching mode-------------
bool app1Flg = true;
bool app2Flg = true;
bool sosFlag = false;
bool tFlag = false;  //Flag to indicate Switch Mode command
bool prev_tFlag = false;
bool app1State;
bool app2State;
bool autoMode;
//---------------------------Commands from User through Mobile App-----------------------------
char cmdKey = 'X';
bool cmdF = false;    //Flag to indicate command received from mobile app
char App1onBuff[4];   //Buffer to store ON time for periodic/timeframe mode
char App1offBuff[4];  //Buffer to store OFF time for periodic/timeframe mode
char App2onBuff[4];
char App2offBuff[4];
char cmdBuff[4];
String sInfo = "";     //Stores device info such as no. of interfaces, its mode and state.
bool initFlg = false;  //Flag variable for device on-start setup configuration
byte i = 0;
//---------------------------Data Point Storage Variables--------------------------------------
const char *path = "/switchData.txt";
char timeStamp[17];
char msg[23];
int tBytes = 0;
int uBytes = 0;
bool wFlag = false;
unsigned int dCount = 0;
//-----------------------------Variables for Switch Mode---------------------------------------
unsigned int min1 = 0;  //Count minutes needed to periodically switch interface 1
unsigned int min2 = 0;  //Count minutes needed to periodically switch interface 2
uint8_t rmin = 0;       //Minute variable needed for Timeframe switch mode operation
uint8_t rhr = 0;        //Hour variable needed for Timeframe switch mode operation
//----------------------- BLE Communication protocol data structure----------------------------
BLEServer *pServer = NULL;
BLECharacteristic *pCharacteristic = NULL;
bool deviceConnected = false;
bool oldDeviceConnected = false;
bool devCon = true;
bool pFlag = false;
//---------------------------------------Function Definition-----------------------------------
void swInfo();
void swConf(char *);
void swReset();
void readData(bool);
void deleteFile();
void readFile();
void writeFile(const char *);
void appendFile(const char *);
void rtcFunc();
void swApp();
//--------------
bool week[7] = { false, false, false, false, false, false, false };
byte cur_day = 7;
byte curr_zone = 5, prev_zone = 0;
bool zoneChg = false;
unsigned int app1ON, app1OFF, app2ON, app2OFF;
char sch_buff[3];
byte sch;
byte frame_App1[18][4];
byte frame_App2[18][4];
char rtcDay[7][10] = { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" };
byte App1Sch;
byte App2Sch;
byte b = 0;
byte diff = 0;
//-------------------------Critical section code that executes every minute---------------------
volatile bool timerFlg = false;
hw_timer_t *timer = NULL;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;
void IRAM_ATTR onTime() {
  portENTER_CRITICAL_ISR(&timerMux);
  timerFlg = true;
  portEXIT_CRITICAL_ISR(&timerMux);
}
//---------------------- Callback function related to device connection------------------------
class MyServCallbacks : public BLEServerCallbacks {
  void onConnect(BLEServer *pServer) {
    deviceConnected = true;
  }
  void onDisconnect(BLEServer *pServer) {
    deviceConnected = false;
  }
};
//-------------------Callback function for read/write charactersitic value---------------------
class MyCallbacks : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic *pCharacteristic) {
    std::string value = pCharacteristic->getValue();
    /*
     * Check for commands received from Mobile App
     *  Info command             : I swInfo()
     *  Switch command           : S swApp()
     *    Periodic               : P
     *    Timeframe              : T
     *    Manual                 : M             : 
     *  Factory Reset command    : F 
     *  Restart command          : R
     *  Data Sync command        : D 
     *  Switch Resume command    : B
     *  Pause command            : P
     *  Auto mode                : A
     *  RTC Adjust command       : C
     */
    if (value.length() > 0) {
      pref.begin("store", false);
      cmdF = true;
      if ((smode == 'P') || (smode == 'T'))
        timerAlarmDisable(timer);
      char cmd[(value.length()) + 1];
      uint8_t cdelm = 0;
      i = 0;
      while (i <= value.length()) {
        cmd[i] = value[i];
        i++;
      }
      cmd[i] = '\0';
      Serial.println("-----------");
      i = 0;
      //------------------------------------------------------//
      //Parsing CSV command data to extract useful information
      //------------------------------------------------------//
      if (cmd[i] == 'F' && cmd[i + 1] == '\0') {  //[Factory Reset Command]
        cmdKey = 'F';
        Serial.println("Factory Reset Command");  //Command Format: {'F','\0'}
        nvs_flash_erase();                        //Erase Non-Voltage Storage (NVS) which stores state variables
        nvs_flash_init();
        deleteFile();  //Delete data point file stored in SPIFFS FileSystem
        ESP.restart();
      } else if (cmd[i] == 'I' && cmd[i + 1] == '\0')  //[Switch Info Command]
      {                                                //Command Format: {'I', '\0'}
        cmdKey = 'I';
        Serial.println("Info Command");
        swInfo();
      } else if (cmd[i] == 'D' && cmd[i + 1] == '\0')  //[Data Sync Command]
      {
        cmdKey = 'D';
        Serial.println("Data Sync Command");
        readFile();
      } else if (cmd[i] == 'T' && cmd[i + 1] == '\0') {  //[Time Command]
        cmdKey = 'T';
        Serial.println("RTC Command");  //Command Format: {'T','\0'}
        rtcFunc();
        pCharacteristic->setValue(timeStamp);
        pCharacteristic->notify();
      } else if (cmd[i] == 'R' && cmd[i + 1] == '\0') {  //[Restart Command]
        cmdKey = 'R';
        Serial.println("Restart Command");  //Command Format: {'R','\0'}
        ESP.restart();
      } else if (cmd[i] == 'A' && cmd[i + 3] == '\0') {
        Serial.println("Auto Mode Command");
        if (cmd[i + 1] == delm) {
          if (cmd[i + 2] == '1') {
            autoMode = 1;
            pref.putBool("auto", autoMode);
            pCharacteristic->setValue("[AUTO MODE] ON");
            pCharacteristic->notify();
          } else if (cmd[i + 2] == '0') {
            autoMode = 0;
            pref.putBool("auto", autoMode);
            pCharacteristic->setValue("[AUTO MODE] OFF");
            pCharacteristic->notify();
          } else {
            Serial.println("Invalid Auto Mode");
            pCharacteristic->setValue("[Error]Invalid Auto Mode");
            pCharacteristic->notify();
          }
        } else {
          Serial.println("Invalid Command");
          pCharacteristic->setValue("[Error]Invalid Command");
          pCharacteristic->notify();
        }
      } else if (cmd[i] == 'B' && cmd[i + 1] == '\0')  //[Switch Resume Command]
      {                                                //Command Format: {'B', '\0'}
        cmdKey = 'B';
        Serial.println("Resume Command");
        tFlag = true;
        if (smode == 'M') {
          pCharacteristic->setValue("[Resume] M ");
          pCharacteristic->notify();
        } else if (smode == 'P') {
          char sendStr[22];
          sprintf(sendStr, "%s:%d,%d", "[Resume] P", min1, min2);
          Serial.println(min1);
          Serial.println(min2);
          pCharacteristic->setValue(sendStr);
          pCharacteristic->notify();
          timerAlarmEnable(timer);
        } else if (smode == 'T') {
          pCharacteristic->setValue("[Resume] T");
          pCharacteristic->notify();
          timerAlarmEnable(timer);
        }
        if (app[0].curr_state) digitalWrite(AP1_pin, HIGH);
        else
          digitalWrite(AP1_pin, LOW);

        if (app[1].curr_state) digitalWrite(AP2_pin, HIGH);
        else
          digitalWrite(AP2_pin, LOW);
      } else if (cmd[i] == 'P' && cmd[i + 1] == '\0')  //[Switch Pause Command]
      {                                                //Command Format: {'P', '\0'}
        cmdKey = 'P';
        Serial.println("Pause Command");
        tFlag = false;
        if (smode == 'M') {
          pCharacteristic->setValue("[Paused] M ");
          pCharacteristic->notify();
        } else if (smode == 'P') {
          pCharacteristic->setValue("[Paused] P");
          pCharacteristic->notify();
        } else if (smode == 'T') {
          pCharacteristic->setValue("[Paused] T");
          pCharacteristic->notify();
        }
      } else if (cmd[i] == 'S' && cmd[i + 1] != '\0')  //[Switch Mode Command]
      {
        cmdKey = 'S';
        Serial.println("Switch Command");
        /*
         * Format:{'S','Mode', 'Value', '\0'}
         * If Mode = 'M'  (Manual),     then Value = {'0/1')
         * If Mode = 'P'  (Periodic),   then Value = {'Day, Zone, ONTIME, OFFTIME' (in MINUTES)}
         * If Mode = 'T'  (Timeframe),  then Value = {'Day, Zone, ONTIME' (in HR:MIN)}
         */
        int j = 0;
        i++;
        while (cmd[i] != NULL) {
          if (cmd[i] == delm) {
            cdelm++;
            j = 0;
            i++;
            continue;
          }
          if (cdelm == 1) {                //Mode
            pref.putBool("svFlg", 1);      //svFlag indicates stored data for setup configuration
            pref.putChar("mode", cmd[i]);  //Mode variable is saved in NVS flash area
            //smode = pref.getChar("mode", 0);
            smode = cmd[i];
            i++;
          } else if (cdelm == 2) {                          //---------------Value------------------
            if (smode == 'M') {                             //[Manual]
              pref.putBool("man1", (cmd[i] - 48));          //Appliance 1 manual value stored in NVS
              pref.putBool("man2", (cmd[i = i + 2] - 48));  //Appliance 2 manual value stored in NVS
              app[0].val[0].mData = pref.getBool("man1", 0);
              app[1].val[0].mData = pref.getBool("man2", 0);
              Serial.println(app[0].val[0].mData);
              Serial.println(app[1].val[0].mData);
              i++;
            } else if (smode == 'P') {  //[Periodic]
              //S,P,SMTWTFS,[Zone1(ONOFFONOFF)],[Zone2(ONOFFONOFF)],[Zone3(ONOFFONOFF)],[Zone4(ONOFFONOFF)]
              int k = 0;

              //Get Days
              while (cmd[i] != delm) {
                week[k] = cmd[i++] - 48;
                k++;
              }
              k = 0;

              //Save week data to memory
              pref.putBytes("Week", week, 7);
              i++;
              Serial.print("Week: ");

              for (int l = 0; l < 7; l++) {
                Serial.print(week[l]);
                Serial.print(" ");
              }
              Serial.println();

              //Setting for TimeZone
              for (int m = 0; m < 4; m++) {
                //Appliance 1 ON Time
                while (cmd[i] != delm)
                  App1onBuff[k++] = cmd[i++];
                App1onBuff[k] = NULL;
                i++;
                k = 0;

                //Appliance 1 OFF Time
                while (cmd[i] != delm)
                  App1offBuff[k++] = cmd[i++];
                App1offBuff[k] = NULL;
                i++;
                k = 0;

                //Appliance 2 ON Time
                while (cmd[i] != delm)
                  App2onBuff[k++] = cmd[i++];
                App2onBuff[k] = NULL;
                i++;
                k = 0;

                //Appliance 2 OFF Time
                while (cmd[i] != delm && cmd[i] != NULL)
                  App2offBuff[k++] = cmd[i++];
                App2offBuff[k] = NULL;
                i++;
                k = 0;

                app[0].val[m].onMin = atoi(App1onBuff);
                app[0].val[m].offMin = atoi(App1offBuff);
                app[1].val[m].onMin = atoi(App2onBuff);
                app[1].val[m].offMin = atoi(App2offBuff);
                Serial.print("Timezone: ");
                Serial.println(m);
                Serial.println("--------------------");
                Serial.print("Appliance 1 ON Time: ");
                Serial.println(app[0].val[m].onMin);
                Serial.print("Appliance 1 OFF Time: ");
                Serial.println(app[0].val[m].offMin);
                Serial.print("Appliance 2 ON Time: ");
                Serial.println(app[1].val[m].onMin);
                Serial.print("Appliance 2 OFF Time: ");
                Serial.println(app[1].val[m].offMin);
                Serial.println("--------------------");
              }
              prev_zone = 0;
              //Appliance 1 Zone 1
              pref.putInt("z1A1ON", app[0].val[0].onMin);
              pref.putInt("z1A1OFF", app[0].val[0].offMin);
              //Appliance 1 Zone 2
              pref.putInt("z2A1ON", app[0].val[1].onMin);
              pref.putInt("z2A1OFF", app[0].val[1].offMin);
              //Appliance 1 Zone 3
              pref.putInt("z3A1ON", app[0].val[2].onMin);
              pref.putInt("z3A1OFF", app[0].val[2].offMin);
              //Appliance 1 Zone 4
              pref.putInt("z4A1ON", app[0].val[3].onMin);
              pref.putInt("z4A1OFF", app[0].val[3].offMin);

              //Appliance 2 Zone 1
              pref.putInt("z1A2ON", app[1].val[0].onMin);
              pref.putInt("z1A2OFF", app[1].val[0].offMin);
              //Appliance 2 Zone 2
              pref.putInt("z2A2ON", app[1].val[1].onMin);
              pref.putInt("z2A2OFF", app[1].val[1].offMin);
              //Appliance 2 Zone 3
              pref.putInt("z3A2ON", app[1].val[2].onMin);
              pref.putInt("z3A2OFF", app[1].val[2].offMin);
              //Appliance 2 Zone 4
              pref.putInt("z4A2ON", app[1].val[3].onMin);
              pref.putInt("z4A2OFF", app[1].val[3].offMin);
            } else if (smode == 'T') {  //[Timeframe]
              //S,T,[SMTWTFS],[App1Schedule],{[FROM,TO] App1Schedule times},[App2Schedule],{[FROM,TO] App2Schedule times}
              int k = 0, l = 0, m = 0;
              //Get Days
              while (cmd[i] != delm)
                week[k++] = cmd[i++] - 48;

              //Save week data to memory
              pref.putBytes("Week", week, 7);
              Serial.print("Week: ");
              for (l = 0; l < 7; l++) {
                Serial.print(week[l]);
                Serial.print(" ");
              }
              Serial.println();
              l = 0;
              i++;

              //Get Number of schedule
              while (cmd[i] != delm)
                sch_buff[l++] = cmd[i++];
              sch_buff[l] = NULL;
              App1Sch = atoi(sch_buff);
              Serial.print("[Appliance 1] Schedules: ");
              Serial.println(App1Sch);
              pref.putInt("A1Sch", App1Sch);
              pref.putInt("A1Sch", App1Sch);
              i++;

              //Get Appliance 1 time data
              for (m = 0; m < App1Sch; m++) {
                k = 0;
                l = 0;
                //Appliance 1
                while (k < 4)  //FROM
                  cmdBuff[k++] = cmd[i++] - 48;
                frame_App1[m][l++] = cmdBuff[0] * 10 + cmdBuff[1];
                frame_App1[m][l++] = cmdBuff[2] * 10 + cmdBuff[3];

                k = 0;
                while (k < 4)  //TO
                  cmdBuff[k++] = cmd[i++] - 48;
                frame_App1[m][l++] = cmdBuff[0] * 10 + cmdBuff[1];
                frame_App1[m][l++] = cmdBuff[2] * 10 + cmdBuff[3];
                i++;
              }
              l = 0;

              //Get Number of schedule
              while (cmd[i] != delm)
                sch_buff[l++] = cmd[i++];
              sch_buff[l] = NULL;
              App2Sch = atoi(sch_buff);
              Serial.print("[Appliance 2] Schedules: ");
              Serial.println(App2Sch);
              pref.putInt("A2Sch", App2Sch);
              i++;

              //Get Appliance 2 time data
              for (m = 0; m < App2Sch; m++) {
                k = 0;
                l = 0;
                while (k < 4)  //FROM
                  cmdBuff[k++] = cmd[i++] - 48;
                frame_App2[m][l++] = cmdBuff[0] * 10 + cmdBuff[1];
                frame_App2[m][l++] = cmdBuff[2] * 10 + cmdBuff[3];
                k = 0;
                while (k < 4)  //TO
                  cmdBuff[k++] = cmd[i++] - 48;
                frame_App2[m][l++] = cmdBuff[0] * 10 + cmdBuff[1];
                frame_App2[m][l++] = cmdBuff[2] * 10 + cmdBuff[3];
                i++;
              }
              pref.putBytes("TFA1", frame_App1, 72);
              //Appliance 1 TimeFrame Data
              for (m = 0; m < App1Sch; m++) {
                Serial.print("Appliance 1 Schedule ");
                Serial.println(m + 1);
                Serial.print(frame_App1[m][0]);
                Serial.print(":");
                Serial.print(frame_App1[m][1]);
                Serial.print(" - ");
                Serial.print(frame_App1[m][2]);
                Serial.print(":");
                Serial.println(frame_App1[m][3]);
              }
              pref.putBytes("TFA2", frame_App2, 72);
              //Appliance 2 TimeFrame Data
              for (m = 0; m < App2Sch; m++) {
                Serial.print("Appliance 2 Schedule ");
                Serial.println(m + 1);
                Serial.print(frame_App2[m][0]);
                Serial.print(":");
                Serial.print(frame_App2[m][1]);
                Serial.print(" - ");
                Serial.print(frame_App2[m][2]);
                Serial.print(":");
                Serial.println(frame_App2[m][3]);
              }
              b = 0;
            } else {
              Serial.println("Invalid mode");
              pCharacteristic->setValue("[Error] Invalid Mode");
              pCharacteristic->notify();
            }
          } else {
            Serial.println("Invalid command");
            pCharacteristic->setValue("[Error] Invalid Command");
            pCharacteristic->notify();
          }
        }
        tFlag = true;
        pref.putBool("prev_tFlag", tFlag);
        swApp();
      } else if (cmd[i] == 'C')  //[RTC Time Adjust Command]
      {                          //Command Format: {'C', '\0'}
        cmdKey = 'C';
        Serial.println("RTC Time Adjust Command");
        i++;
        unsigned int yrr, mnth, dy, hrr, mnn, n;
        char buf[5];
        if (cmd[i] == delm) {
          i++;
          for (n = 0; n < 4; n++)  //Year
            buf[n] = cmd[i++];
          buf[n] = NULL;
          yrr = atoi(buf);
          i++;
          for (n = 0; n < 2; n++)  //Month
            buf[n] = cmd[i++];
          buf[n] = NULL;
          mnth = atoi(buf);
          i++;
          for (n = 0; n < 2; n++)  //Day
            buf[n] = cmd[i++];
          buf[n] = NULL;
          dy = atoi(buf);
          i++;
          for (n = 0; n < 2; n++)  //Hr
            buf[n] = cmd[i++];
          buf[n] = NULL;
          hrr = atoi(buf);
          i++;
          for (n = 0; n < 2; n++)  //Min
            buf[n] = cmd[i++];
          buf[n] = NULL;
          mnn = atoi(buf);

          rtc.adjust(DateTime(yrr, mnth, dy, hrr, mnn, 0));
          Serial.println("RTC Time Adjusted.");
          pCharacteristic->setValue("RTC Time Adjusted.");
          pCharacteristic->notify();
        } else {
          Serial.println("[Error]Invalid RTC Command");
          pCharacteristic->setValue("[Error] Invalid RTC Command");
          pCharacteristic->notify();
        }
      } else {
        Serial.println("[Error]Invalid Command");
        pCharacteristic->setValue("[Error] Invalid Command");
        pCharacteristic->notify();
      }
      cmdF = false;
      if ((smode == 'P') || (smode == 'T'))
        timerAlarmEnable(timer);
      pref.end();
    }
  }
};

void defaultState() {
  // Configure the Prescaler at 80 the quarter of the ESP32 is cadence at 80Mhz
  // 80000000 / 80 = 1000000 tics / seconde
  timer = timerBegin(0, 80, true);  //true - count up; false - count down
  timerAttachInterrupt(timer, &onTime, true);
  timerAlarmWrite(timer, 60 * 1000000, true);
  timerAlarmDisable(timer);

  tFlag = false;
  pref.putBool("prev_tFlag", false);

  smode = 'M';
  initFlg = false;

  app[0].ID[0] = '0';
  app[0].ID[1] = '1';
  app[0].ID[2] = NULL;
  app[1].ID[0] = '0';
  app[1].ID[1] = '2';
  app[1].ID[2] = NULL;

  app[0].prev_state = 0;
  app[0].curr_state = 0;
  app[1].prev_state = 0;
  app[1].curr_state = 0;

  app[0].val[0].mData = 0;
  app[1].val[0].mData = 0;

  for (int k = 0; k < 4; k++) {
    app[0].val[k].onMin = 0;
    app[0].val[k].offMin = 0;
    app[1].val[k].onMin = 0;
    app[1].val[k].offMin = 0;
  }

  for (i = 0; i < 4; i++) {
    app[0].val[0].tON[i] = 0;
    app[1].val[0].tON[i] = 0;
  }

  for (i = 0; i < 18; i++) {
    for (int k = 0; k < 4; k++) {
      frame_App1[i][k] = 0;
      frame_App2[i][k] = 0;
    }
  }
  sch = 0;
  App1Sch = 0;
  App2Sch = 0;
  prev_zone = 0;
  autoMode = 0;
  zoneChg = false;

  //Timeframe
  for (i = 0; i < 7; i++)
    week[i] = 0;
  App1Sch = 0;
  App2Sch = 0;
  for (i = 0; i < 18; i++) {
    for (int j = 0; j < 4; j++)
      frame_App1[i][j] = 0;
  }

  for (i = 0; i < 18; i++) {
    for (int j = 0; j < 4; j++)
      frame_App2[i][j] = 0;
  }
  writeFile("Dy/M/Y,H:M,App1,App2\r\n");
}

void savedData() {
  // Configure the Prescaler at 80 the quarter of the ESP32 is cadence at 80Mhz
  // 80000000 / 80 = 1000000 tics / seconde
  timer = timerBegin(0, 80, true);  //true - count up; false - count down
  timerAttachInterrupt(timer, &onTime, true);
  timerAlarmWrite(timer, 60 * 1000000, true);  //1 minute Timer
  timerAlarmDisable(timer);

  smode = pref.getChar("mode", 0);

  app[0].ID[0] = '0';
  app[0].ID[1] = '1';
  app[0].ID[2] = NULL;
  app[1].ID[0] = '0';
  app[1].ID[1] = '2';
  app[1].ID[2] = NULL;

  app[0].prev_state = pref.getBool("pState1", 0);
  app[0].curr_state = 0;
  app[1].prev_state = pref.getBool("pState2", 0);
  app[1].curr_state = 0;
  //Manual Mode
  app[0].val[0].mData = pref.getBool("man1", 0);
  app[1].val[0].mData = pref.getBool("man2", 0);
  //Period Mode
  app[0].val[0].onMin = pref.getInt("z1A1ON", 0);
  app[0].val[0].offMin = pref.getInt("z1A1OFF", 0);
  app[0].val[1].onMin = pref.getInt("z2A1ON", 0);
  app[0].val[1].offMin = pref.getInt("z2A1OFF", 0);
  app[0].val[2].onMin = pref.getInt("z3A1ON", 0);
  app[0].val[2].offMin = pref.getInt("z3A1OFF", 0);
  app[0].val[3].onMin = pref.getInt("z4A1ON", 0);
  app[0].val[3].offMin = pref.getInt("z4A1OFF", 0);

  app[1].val[0].onMin = pref.getInt("z1A2ON", 0);
  app[1].val[0].offMin = pref.getInt("z1A2OFF", 0);
  app[1].val[1].onMin = pref.getInt("z2A2ON", 0);
  app[1].val[1].offMin = pref.getInt("z2A2OFF", 0);
  app[1].val[2].onMin = pref.getInt("z3A2ON", 0);
  app[1].val[2].offMin = pref.getInt("z3A2OFF", 0);
  app[1].val[3].onMin = pref.getInt("z4A2ON", 0);
  app[1].val[3].offMin = pref.getInt("z4A2OFF", 0);

  min1 = pref.getUInt("m1", 0);
  min2 = pref.getUInt("m2", 0);

  //Timeframe
  pref.getBytes("Week", week, 7);
  App1Sch = pref.getInt("A1Sch", 0);
  App2Sch = pref.getInt("A2Sch", 0);
  pref.getBytes("TFA1", frame_App1, 72);
  pref.getBytes("TFA2", frame_App1, 72);

  autoMode = pref.getBool("auto", 0);
  if (autoMode == 1) {
    tFlag = true;
    Serial.println("[AUTO MODE] ON");
    pCharacteristic->setValue("[AUTO MODE] ON");
    pCharacteristic->notify();
    if ((smode == 'P') || (smode == 'T'))
      timerAlarmEnable(timer);
  } else {
    tFlag = false;
    Serial.println("[AUTO MODE] OFF");
    pCharacteristic->setValue("[AUTO MODE] OFF");
    pCharacteristic->notify();
  }
}

void setup() {
  Serial.begin(115200);
  //BLE Configuration
  bleConf();
  if (!SPIFFS.begin(FORMAT_SPIFFS_IF_FAILED)) {
    Serial.println("SPIFFS Mount Failed");
    pCharacteristic->setValue("[Error] File System");
    pCharacteristic->notify();
    return;
  }
  pref.begin("store", false);
  initFlg = pref.getBool("svFlg", 0);
  if (initFlg) {
    Serial.println("Loading saved configuration...");
    savedData();
  } else {
    Serial.println("Loading default configuration...");
    defaultState();
  }

  pref.end();

  pinMode(AP1_pin, OUTPUT);
  pinMode(AP2_pin, OUTPUT);
  pinMode(SOS_Button, INPUT);
  digitalWrite(AP1_pin, LOW);
  digitalWrite(AP2_pin, LOW);

  while ((!rtc.begin()) && i < 5) {
    Serial.println("Couldn't find RTC");
    pCharacteristic->setValue("[Error] RTC not found.");
    pCharacteristic->notify();
    i++;
  }
  rtc.adjust(DateTime(__DATE__, __TIME__));
}

void bleConf() {
  Serial.println("Starting BLE Switch!");

  BLEDevice::init("BLE_Switch");

  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServCallbacks());

  BLEService *pService = pServer->createService(SERVICE_UUID);

  pCharacteristic = pService->createCharacteristic(
    CHARACTERISTIC_UUID,
    BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_NOTIFY | BLECharacteristic::PROPERTY_WRITE);
  pCharacteristic->addDescriptor(new BLE2902());
  pCharacteristic->setCallbacks(new MyCallbacks());
  pService->start();

  // BLEAdvertising *pAdvertising = pServer->getAdvertising();  // this still is working for backward compatibility
  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(SERVICE_UUID);
  pAdvertising->setScanResponse(false);
  pAdvertising->setMinPreferred(0x00);  // functions that help with iPhone connections issue 0x06
  //pAdvertising->setMinPreferred(0x12);
  BLEDevice::startAdvertising();
  Serial.println("Characteristic defined! Now you can read it in your phone!");
}

void stateChg() {
  rtcFunc();
  strcpy(msg, timeStamp);
  strcat(msg, ",");
  if (app[0].curr_state) strcat(msg, "1");
  else
    strcat(msg, "0");
  strcat(msg, ",");
  if (app[1].curr_state) strcat(msg, "1");
  else
    strcat(msg, "0");
  strcat(msg, "\r\n");
  appendFile(msg);
  /*pref.begin("store",false);
  pref.putBool("pState1", app[0].prev_state);  
  //pref.putBool("cState1", app[0].curr_state);
  pref.putBool("pState2", app[1].prev_state);
  //pref.putBool("cState2", app[1].curr_state);
  pref.end();*/
}

void feedWDT() {
  TIMERG0.wdt_wprotect = TIMG_WDT_WKEY_VALUE;
  TIMERG0.wdt_feed = 1;
  TIMERG0.wdt_wprotect = 0;
}

void periodMode() {
  if (timerFlg) {
    // Comment out enter / exit to deactivate the critical section
    portENTER_CRITICAL(&timerMux);
    timerFlg = false;
    portEXIT_CRITICAL(&timerMux);
    rtcFunc();

    //Get ON and OFF time for respective timezone
    if (zoneChg) {
      switch (curr_zone) {
        case 1:
          if (app[0].val[0].onMin > 0 || app[0].val[0].offMin > 0 || app[1].val[0].onMin > 0 || app[1].val[0].offMin > 0) {
            min1 = 0;
            min2 = 0;
            app1ON = app[0].val[0].onMin;
            app1OFF = app[0].val[0].offMin;
            app2ON = app[1].val[0].onMin;
            app2OFF = app[1].val[0].offMin;
            Serial.println("TimeZone 1 Periodic Mode Set");
            pFlag = true;
          } else
            pFlag = false;
          break;
        case 2:
          if (app[0].val[1].onMin > 0 || app[0].val[1].offMin > 0 || app[1].val[1].onMin > 0 || app[1].val[1].offMin > 0) {
            min1 = 0;
            min2 = 0;
            app1ON = app[0].val[1].onMin;
            app1OFF = app[0].val[1].offMin;
            app2ON = app[1].val[1].onMin;
            app2OFF = app[1].val[1].offMin;
            pFlag = true;
            Serial.println("TimeZone 2 Periodic Mode Set");
          } else
            pFlag = false;
          break;
        case 3:
          if (app[0].val[2].onMin > 0 || app[0].val[2].offMin > 0 || app[1].val[2].onMin > 0 || app[1].val[2].offMin > 0) {
            min1 = 0;
            min2 = 0;
            app1ON = app[0].val[2].onMin;
            app1OFF = app[0].val[2].offMin;
            app2ON = app[1].val[2].onMin;
            app2OFF = app[1].val[2].offMin;
            pFlag = true;
            Serial.println("TimeZone 3 Periodic Mode Set");
          } else
            pFlag = false;
          break;
        case 4:
          if (app[0].val[3].onMin > 0 || app[0].val[3].offMin > 0 || app[1].val[3].onMin > 0 || app[1].val[3].offMin > 0) {
            min1 = 0;
            min2 = 0;
            app1ON = app[0].val[3].onMin;
            app1OFF = app[0].val[3].offMin;
            app2ON = app[1].val[3].onMin;
            app2OFF = app[1].val[3].offMin;
            pFlag = true;
            Serial.println("TimeZone 4 Periodic Mode Set");
          } else
            pFlag = false;
          break;
      }
      if (!pFlag) {
        Serial.print("No time setting for Timezone: ");
        Serial.println(curr_zone);
        app1ON = 0;
        app1OFF = 0;
        app2ON = 0;
        app2OFF = 0;
      }

      Serial.print("Appliance 1 ON TIME: ");
      Serial.println(app1ON);
      Serial.print("Appliance 1 OFF TIME: ");
      Serial.println(app1OFF);
      Serial.print("Appliance 2 ON TIME: ");
      Serial.println(app2ON);
      Serial.print("Appliance 2 OFF TIME: ");
      Serial.println(app2OFF);
    }
    min1++;
    min2++;

    pref.begin("store", false);
    pref.putUInt("m1", min1);
    pref.putUInt("m2", min2);
    pref.end();

    Serial.print("Period 1: ");
    Serial.println(min1);
    Serial.print("Period 2: ");
    Serial.println(min2);

    if (week[cur_day] && pFlag) {
      //Setting for Appliance 1
      if (min1 <= app1ON) {
        digitalWrite(AP1_pin, HIGH);
        Serial.println("Interface 1: HIGH");
        app[0].curr_state = 1;
      } else if (min1 > app1ON && min1 <= (app1ON + app1OFF)) {
        digitalWrite(AP1_pin, LOW);
        Serial.println("Interface 1: LOW");
        app[0].curr_state = 0;
      } else if (app1ON != 0) {
        digitalWrite(AP1_pin, HIGH);
        Serial.println("Interface 1: HIGH");
        app[0].curr_state = 1;
        min1 = 1;
      }

      //Setting for Appliance 2
      if (min2 <= app2ON) {
        digitalWrite(AP2_pin, HIGH);
        Serial.println("Interface 2: HIGH");
        app[1].curr_state = 1;
      } else if (min2 > app2ON && min2 <= (app2ON + app2OFF)) {
        digitalWrite(AP2_pin, LOW);
        Serial.println("Interface 2: LOW");
        app[1].curr_state = 0;
      } else if (app2OFF != 0) {
        digitalWrite(AP2_pin, HIGH);
        Serial.println("Interface 2: HIGH");
        app[1].curr_state = 1;
        min2 = 1;
      }
    } else {
      digitalWrite(AP1_pin, LOW);
      digitalWrite(AP2_pin, LOW);
      Serial.println("Interface 1: LOW");
      Serial.println("Interface 2: LOW");
    }
  }
}

void timeFrameMode() {
  if (timerFlg) {
    // Comment out enter / exit to deactivate the critical section
    portENTER_CRITICAL(&timerMux);
    timerFlg = false;
    portEXIT_CRITICAL(&timerMux);
    rtcFunc();
    //Check Appliance 1 schedules
    if (week[cur_day] && App1Sch > 0) {
      for (int b = 0; b < App1Sch; b++) {
        diff = frame_App1[b][2] - frame_App1[b][0];
        if (diff > 0) {
          if (rhr == frame_App1[b][0]) {
            if ((rhr >= frame_App1[b][0] && rmin >= frame_App1[b][1]) && (rhr <= frame_App1[b][0] && rmin <= 59)) {
              app[0].curr_state = 1;
              break;
            } else
              app[0].curr_state = 0;
          } else if (rhr == frame_App1[b][2]) {
            if ((rhr >= frame_App1[b][2] && rmin >= 0) && (rhr <= frame_App1[b][2] && rmin <= frame_App1[b][3])) {
              app[0].curr_state = 1;
              break;
            } else
              app[0].curr_state = 1;
          } else {
            for (int l = 1; l < diff; l++) {
              if ((rhr >= (frame_App1[b][0] + l) && rmin >= 0) && (rhr <= (frame_App1[b][0] + l) && rmin <= 59)) {
                app[0].curr_state = 1;
                break;
              } else
                app[0].curr_state = 0;
            }
          }
        } else {
          if ((rhr >= frame_App1[b][0] && rmin >= frame_App1[b][1]) && (rhr <= frame_App1[b][2] && rmin < frame_App1[b][3])) {
            app[0].curr_state = 1;
            break;
          } else
            app[0].curr_state = 0;
        }
      }
    } else {
      app[0].curr_state = 0;
    }
    //Check Appliance 2 schedules
    if (week[cur_day] && App2Sch > 0) {
      for (int b = 0; b < App2Sch; b++) {
        diff = frame_App2[b][2] - frame_App2[b][0];
        if (diff > 0) {
          if (rhr == frame_App2[b][0]) {
            if ((rhr >= frame_App2[b][0] && rmin >= frame_App2[b][1]) && (rhr <= frame_App2[b][0] && rmin <= 59)) {
              app[1].curr_state = 1;
              break;
            } else
              app[1].curr_state = 0;
          } else if (rhr == frame_App2[b][2]) {
            if ((rhr >= frame_App2[b][2] && rmin >= 0) && (rhr <= frame_App2[b][2] && rmin < frame_App2[b][3])) {
              app[1].curr_state = 1;
              break;
            } else
              app[1].curr_state = 0;
          } else {
            for (int l = 1; l < diff; l++) {
              if ((rhr >= (frame_App2[b][0] + l) && rmin >= 0) && (rhr <= (frame_App2[b][0] + l) && rmin <= 59)) {
                app[1].curr_state = 1;
                break;
              } else
                app[1].curr_state = 0;
            }
          }
        } else {
          if ((rhr >= frame_App2[b][0] && rmin >= frame_App2[b][1]) && (rhr <= frame_App2[b][2] && rmin < frame_App2[b][3])) {
            app[1].curr_state = 1;
            break;
          } else
            app[1].curr_state = 0;
        }
      }
    } else {
      app[1].curr_state = 0;
    }

    if (app[0].curr_state == 1) {
      Serial.println("Appliance 1: HIGH");
      digitalWrite(AP1_pin, HIGH);
    } else {
      Serial.println("Appliance 1: LOW");
      digitalWrite(AP1_pin, LOW);
    }

    if (app[1].curr_state == 1) {
      Serial.println("Appliance 2: HIGH");
      digitalWrite(AP2_pin, HIGH);
    } else {
      Serial.println("Appliance 2: LOW");
      digitalWrite(AP2_pin, LOW);
    }
  }
}

void manualMode() {
  if (app1Flg) {
    if (app[0].val[0].mData == 1) {
      Serial.println("Appliance 1: HIGH");
      digitalWrite(AP1_pin, HIGH);
    } else {
      Serial.println("Appliance 1: LOW");
      digitalWrite(AP1_pin, LOW);
    }
    app[0].curr_state = app[0].val[0].mData;
    app1Flg = false;
  }
  if (app2Flg) {
    if (app[1].val[0].mData == 1) {
      Serial.println("Appliance 2: HIGH");
      digitalWrite(AP2_pin, HIGH);
    } else {
      Serial.println("Appliance 2: LOW");
      digitalWrite(AP2_pin, LOW);
    }
    app[1].curr_state = app[1].val[0].mData;
    app2Flg = false;
  }
}

void emergencyCheck() {
  if (digitalRead(SOS_Button) == HIGH) {
    if (!sosFlag) {
      Serial.println("EMERGENCY ON!");
      pCharacteristic->setValue("EMERGENCY ON!");
      pCharacteristic->notify();
      digitalWrite(AP1_pin, 0);
      digitalWrite(AP2_pin, 0);
      if (smode == 'P' || smode == 'T') {
        Serial.println("Timer Stopped!");
        tFlag = false;
        //timerAlarmDisable(timer);
      }
      sosFlag = true;
    }
    delay(1);
  } else {
    if (sosFlag) {
      if (app[0].curr_state) digitalWrite(AP1_pin, HIGH);
      else
        digitalWrite(AP1_pin, LOW);

      //if(app[1].curr_state)
      digitalWrite(AP2_pin, app[1].curr_state);
      //else
      digitalWrite(AP2_pin, app[1].curr_state);
      sosFlag = false;
      Serial.println("EMERGENCY OFF!");
      pCharacteristic->setValue("EMERGENCY OFF!");
      pCharacteristic->notify();
      if (smode == 'P' || smode == 'T')
        tFlag = true;
      //timerAlarmEnable(timer);
    }
  }
}

void loop() {
  bleDevice();
  feedWDT();
  vTaskDelay(5 / portTICK_PERIOD_MS);
  //emergencyCheck();
  if (!tFlag)
    timerAlarmDisable(timer);
  else if (!cmdF && tFlag) {
    if (smode == 'M')
      manualMode();
    else if (smode == 'P')
      periodMode();
    else if (smode == 'T')
      timeFrameMode();
  }

  if ((app[0].prev_state != app[0].curr_state) || (app[1].prev_state != app[1].curr_state))
    stateChg();

  pref.begin("store", false);
  pref.putBool("pState1", app[0].curr_state);
  pref.putBool("pState2", app[1].curr_state);
  app[0].prev_state = pref.getBool("pState1", 0);
  app[1].prev_state = pref.getBool("pState2", 0);
  pref.end();

  delay(500);
}

void swApp() {
  app1Flg = true;
  app2Flg = true;
  min1 = 0;
  min2 = 0;
  switch (smode) {
    case 'M':
      Serial.println("------------");
      Serial.println("MANUAL MODE:");
      Serial.println("------------");
      pCharacteristic->setValue("[MODE] Manual");
      pCharacteristic->notify();
      break;
    case 'P':
      Serial.println("------------");
      Serial.println("PERIOD MODE:");
      Serial.println("------------");
      pCharacteristic->setValue("[MODE] Periodic");
      pCharacteristic->notify();

      app[0].curr_state = 0;
      app[1].curr_state = 0;

      //Interface 1
      digitalWrite(AP1_pin, LOW);
      Serial.println("Interface 1: LOW");
      //Interface 2
      digitalWrite(AP2_pin, LOW);
      Serial.println("Interface 2: LOW");
      timerAlarmEnable(timer);
      break;
    case 'T':
      Serial.println("------------");
      Serial.println("TIMEFRAME MODE:");
      Serial.println("------------");
      pCharacteristic->setValue("[MODE] Timeframe");
      pCharacteristic->notify();
      app[0].curr_state = 0;
      app[1].curr_state = 0;
      //Interface 1
      digitalWrite(AP1_pin, LOW);
      //Serial.println("Interface 1: LOW");
      //Interface 2
      digitalWrite(AP2_pin, LOW);
      //Serial.println("Interface 2: LOW");
      timerAlarmEnable(timer);
      break;
  }
}

void rtcFunc() {
  DateTime now = rtc.now();
  Serial.print(now.year(), DEC);
  Serial.print('/');
  Serial.print(now.month(), DEC);
  Serial.print('/');
  Serial.print(now.day(), DEC);
  Serial.print(" ");
  cur_day = now.dayOfTheWeek();
  Serial.println(cur_day);
  rhr = now.hour();
  Serial.print(rhr);
  Serial.print(':');
  rmin = now.minute();
  Serial.println(rmin);
  sprintf(timeStamp, "%02d/%02d/%04d,%02d:%02d", now.day(), now.month(), now.year(), now.hour(), now.minute());
  getTimeZone();
}

void getTimeZone() {
  /*TimeZone 1: 06:00 AM to 11:59 AM  (06:00 - 11:59)  
    TimeZone 2: 12:00 PM to 05:59 PM  (12:00 - 17:59)
    TimeZone 3: 06:00 PM to 11:59 PM  (18:00 - 23:59)
    TimeZone 4: 12:00 AM to 05:59 AM  (00:00 - 05:59)
  */
  if (rhr >= 6 && (rhr <= 11 && rmin <= 59)) {
    curr_zone = 1;
  } else if (rhr >= 12 && (rhr <= 17 && rmin <= 59)) {
    curr_zone = 2;
  } else if (rhr >= 18 && (rhr <= 23 && rmin <= 59)) {
    curr_zone = 3;
  } else if (rhr >= 00 && (rhr <= 5 && rmin <= 59)) {
    curr_zone = 4;
  }
  if (prev_zone != curr_zone)
    zoneChg = true;
  else
    zoneChg = false;
  prev_zone = curr_zone;
}

void bleDevice() {
  if (deviceConnected) {
    if (devCon) {
      swInfo();
      pCharacteristic->setValue("[BLE Switch] Ready");
      pCharacteristic->notify();
      devCon = false;
    }
  }
  if (!deviceConnected && oldDeviceConnected) {
    delay(500);
    //BLEDevice::startAdvertising();
    pServer->startAdvertising();
    Serial.println("Start Advertising again...");
    oldDeviceConnected = deviceConnected;
    devCon = true;
  }

  if (deviceConnected && !oldDeviceConnected) {
    oldDeviceConnected = deviceConnected;
  }
}

void swInfo() {
  /*Information related to node:
   * Number of Interfaces
   * Interface ID
   * Interface State
   * Interface Mode: Periodic (P) or Manual (M)
   * Interface value: seconds or ON/OFF(1/0)
   */
  char b[200];

  sInfo = String(nInterface) + ',' + String(app[0].prev_state) + ',' + String(app[1].prev_state) + ',' + String(app[0].ID) + ',' + String(app[0].curr_state) + ',' + String(app[1].ID) + ',' + String(app[1].curr_state) + ',' + String(smode) + ',';
  if (smode == 'M') {
    sInfo += String(app[0].val[0].mData) + ',' + String(app[1].val[0].mData);
  } else if (smode == 'P') {
    for (int i = 0; i < 7; i++)
      sInfo += String(week[i]);
    sInfo += ',' + String(app[0].val[0].onMin) + ',' + String(app[0].val[0].offMin) + ',' + String(app[1].val[0].onMin) + ',' + String(app[1].val[0].offMin)
             + ',' + String(app[0].val[1].onMin) + ',' + String(app[0].val[1].offMin) + ',' + String(app[1].val[1].onMin) + ',' + String(app[1].val[1].offMin)
             + ',' + String(app[0].val[2].onMin) + ',' + String(app[0].val[2].offMin) + ',' + String(app[1].val[2].onMin) + ',' + String(app[1].val[2].offMin)
             + ',' + String(app[0].val[3].onMin) + ',' + String(app[0].val[3].offMin) + ',' + String(app[1].val[3].onMin) + ',' + String(app[1].val[3].offMin);
  } else if (smode == 'T') {
    for (int i = 0; i < 7; i++)
      sInfo += String(week[i]);
    sInfo += ',' + String(App1Sch) + ',';
    for (int m = 0; m < App1Sch; m++) {
      for (int l = 0; l < 4; l++) {
        if (frame_App1[m][l] < 10)
          sInfo += '0' + String(frame_App1[m][l]);
        else
          sInfo += String(frame_App1[m][l]);
      }
      sInfo += ',';
    }
    sInfo += String(App2Sch) + ',';
    for (int m = 0; m < App2Sch; m++) {
      for (int l = 0; l < 4; l++) {
        if (frame_App2[m][l] < 10)
          sInfo += '0' + String(frame_App2[m][l]);
        else
          sInfo += String(frame_App2[m][l]);
      }
      if (m != (App2Sch - 1))
        sInfo += ',';
    }
  }
  sInfo.toCharArray(b, 200);
  //dtostrf("12", 1, 2, data);
  Serial.println(b);
  pCharacteristic->setValue(b);
  pCharacteristic->notify();
  //delay(1000);
}

void readFile() {
  const char *path = "/s2230821ae406.txt";
  Serial.printf("Reading file: %s\r\n", path);
  char buf[23];
  size_t len;
  size_t bytesRead = 0;
  File file = SPIFFS.open(path);
  if (!file || file.isDirectory()) {
    Serial.println("− failed to open file for reading");
    pCharacteristic->setValue("[Error]F Read");
    pCharacteristic->notify();
    return;
  }

  Serial.println("Syncing Data....:");
  pCharacteristic->setValue("Syncing Data...");
  pCharacteristic->notify();
  len = file.size();
  while (file.available()) {
    int l = file.readBytesUntil('\n', buf, (sizeof(buf) - 1));
    bytesRead += (l + 1);
    buf[l] = 0;
    Serial.println(buf);
    pCharacteristic->setValue(buf);
    pCharacteristic->notify();
    delay(200);
  }
  tBytes = SPIFFS.totalBytes();
  //uBytes = SPIFFS.usedBytes();
  Serial.print("Total bytes: ");
  Serial.println(tBytes);
  Serial.print("Bytes Read: ");
  Serial.println(bytesRead);
  Serial.print("File Size: ");
  Serial.println(file.size());
  file.close();
  if (bytesRead == len) {
    pCharacteristic->setValue("Data Synced!");
    pCharacteristic->notify();
    deleteFile();
  } else {
    pCharacteristic->setValue("[Error]Data Sync Failed.");
    pCharacteristic->notify();
  }
}

void writeFile(const char *message) {
  Serial.printf("Writing file: %s\r\n", path);
  File file = SPIFFS.open(path, FILE_WRITE);
  if (!file) {
    Serial.println("[Error]FO");
    pCharacteristic->setValue("[Error]FO");
    pCharacteristic->notify();
    return;
  }
  if (file.print(message)) {
    Serial.println("[Success]FW");
  } else {
    Serial.println("[Error]FW");
    pCharacteristic->setValue("[Error]FW");
    pCharacteristic->notify();
  }
  file.close();
}

void appendFile(const char *message) {
  if (dCount == 3000) {
    Serial.println("File is Full. Deleting...");
    deleteFile();
    writeFile("Dy/M/Y,H:M,App1,App2\r\n");
    dCount = 0;
  }
  delay(2);
  Serial.printf("Appending to file: %s\r\n", path);
  File file = SPIFFS.open(path, FILE_APPEND);
  if (!file) {
    Serial.println("[Error]FO");
    pCharacteristic->setValue("[Error]FO");
    pCharacteristic->notify();
    return;
  }
  if (file.print(message)) {
    Serial.printf("[Success]FA: %s\r\n", path);
    dCount++;
  } else {
    Serial.println("[Error]FA");
    pCharacteristic->setValue("[Error]FA");
    pCharacteristic->notify();
  }
  file.close();
}

void deleteFile() {
  Serial.printf("Deleting file: %s\r\n", path);
  if (SPIFFS.remove(path)) {
    Serial.println("[Success]FD");
  } else {
    Serial.println("[Error]FD");
    pCharacteristic->setValue("[Error]FD");
    pCharacteristic->notify();
  }
}
